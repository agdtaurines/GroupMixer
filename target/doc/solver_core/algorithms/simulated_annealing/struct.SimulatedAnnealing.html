<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Simulated Annealing solver for the Social Group Scheduling Problem."><title>SimulatedAnnealing in solver_core::algorithms::simulated_annealing - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-081576b923113409.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="solver_core" data-themes="" data-resource-suffix="" data-rustdoc-version="1.79.0 (129f3b996 2024-06-10)" data-channel="1.79.0" data-search-js="search-bf21c90c8c1d92b1.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-e32f0c247825364d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-09095024cf37855e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../solver_core/index.html">solver_core</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">SimulatedAnnealing</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.final_temperature">final_temperature</a></li><li><a href="#structfield.initial_temperature">initial_temperature</a></li><li><a href="#structfield.max_iterations">max_iterations</a></li><li><a href="#structfield.no_improvement_iterations">no_improvement_iterations</a></li><li><a href="#structfield.time_limit_seconds">time_limit_seconds</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.new">new</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Solver-for-SimulatedAnnealing">Solver</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-SimulatedAnnealing">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-SimulatedAnnealing">RefUnwindSafe</a></li><li><a href="#impl-Send-for-SimulatedAnnealing">Send</a></li><li><a href="#impl-Sync-for-SimulatedAnnealing">Sync</a></li><li><a href="#impl-Unpin-for-SimulatedAnnealing">Unpin</a></li><li><a href="#impl-UnwindSafe-for-SimulatedAnnealing">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li><li><a href="#impl-VZip%3CV%3E-for-T">VZip&lt;V&gt;</a></li></ul></section><h2><a href="index.html">In solver_core::algorithms::simulated_annealing</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../solver_core/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Type ‘S’ or ‘/’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings">Settings</a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../../index.html">solver_core</a>::<wbr><a href="../index.html">algorithms</a>::<wbr><a href="index.html">simulated_annealing</a>::<wbr><a class="struct" href="#">SimulatedAnnealing</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/solver_core/algorithms/simulated_annealing.rs.html#145-156">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct SimulatedAnnealing {
    pub max_iterations: <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.u64.html">u64</a>,
    pub initial_temperature: <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.f64.html">f64</a>,
    pub final_temperature: <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.f64.html">f64</a>,
    pub time_limit_seconds: <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.u64.html">u64</a>&gt;,
    pub no_improvement_iterations: <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.u64.html">u64</a>&gt;,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Simulated Annealing solver for the Social Group Scheduling Problem.</p>
<p>This implementation combines classical simulated annealing with domain-specific
optimizations for social group scheduling. It intelligently balances exploration
and exploitation while respecting complex constraints like clique integrity.</p>
<h2 id="algorithm-overview"><a class="doc-anchor" href="#algorithm-overview">§</a>Algorithm Overview</h2>
<p>Simulated Annealing is a probabilistic optimization algorithm inspired by the
annealing process in metallurgy. It starts with high “temperature” allowing
many moves (including poor ones) and gradually “cools” to focus on improvements.</p>
<h3 id="key-components"><a class="doc-anchor" href="#key-components">§</a>Key Components</h3>
<ol>
<li><strong>Temperature Schedule</strong>: Controls exploration vs exploitation balance</li>
<li><strong>Move Generation</strong>: Intelligent selection between person swaps and clique moves</li>
<li><strong>Acceptance Criterion</strong>: Metropolis criterion for probabilistic acceptance</li>
<li><strong>Stop Conditions</strong>: Multiple termination criteria for robust convergence</li>
</ol>
<h3 id="move-types"><a class="doc-anchor" href="#move-types">§</a>Move Types</h3><h4 id="regular-swaps"><a class="doc-anchor" href="#regular-swaps">§</a>Regular Swaps</h4>
<ul>
<li>Swaps two individual people between groups</li>
<li>Fast to evaluate and execute</li>
<li>Good for fine-tuning solutions</li>
</ul>
<h4 id="clique-swaps"><a class="doc-anchor" href="#clique-swaps">§</a>Clique Swaps</h4>
<ul>
<li>Moves entire cliques (groups that must stay together)</li>
<li>More complex but respects constraint structure</li>
<li>Essential for problems with many clique constraints</li>
</ul>
<h2 id="configuration"><a class="doc-anchor" href="#configuration">§</a>Configuration</h2>
<p>The algorithm is configured through <code>SimulatedAnnealingParams</code>:</p>
<ul>
<li><code>initial_temperature</code>: Starting temperature (higher = more exploration)</li>
<li><code>final_temperature</code>: Ending temperature (lower = more focused)</li>
<li><code>cooling_schedule</code>: How temperature decreases (currently “geometric”)</li>
</ul>
<p>Stop conditions are configured through <code>StopConditions</code>:</p>
<ul>
<li><code>max_iterations</code>: Maximum optimization iterations</li>
<li><code>time_limit_seconds</code>: Wall-clock time limit</li>
<li><code>no_improvement_iterations</code>: Early stopping on convergence</li>
</ul>
<h2 id="example-usage"><a class="doc-anchor" href="#example-usage">§</a>Example Usage</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>solver_core::algorithms::simulated_annealing::SimulatedAnnealing;
<span class="kw">use </span>solver_core::algorithms::Solver;
<span class="kw">use </span>solver_core::models::<span class="kw-2">*</span>;
<span class="kw">use </span>solver_core::solver::State;
<span class="kw">use </span>std::collections::HashMap;

<span class="comment">// Configure the algorithm
</span><span class="kw">let </span>config = SolverConfiguration {
    solver_type: <span class="string">"SimulatedAnnealing"</span>.to_string(),
    stop_conditions: StopConditions {
        max_iterations: <span class="prelude-val">Some</span>(<span class="number">10000</span>),
        time_limit_seconds: <span class="prelude-val">Some</span>(<span class="number">30</span>),
        no_improvement_iterations: <span class="prelude-val">Some</span>(<span class="number">1000</span>),
    },
    solver_params: SolverParams::SimulatedAnnealing(
        SimulatedAnnealingParams {
            initial_temperature: <span class="number">100.0</span>,  <span class="comment">// High exploration
            </span>final_temperature: <span class="number">0.01</span>,     <span class="comment">// Low exploitation
            </span>cooling_schedule: <span class="string">"geometric"</span>.to_string(),
        }
    ),
    logging: LoggingOptions {
        log_frequency: <span class="prelude-val">Some</span>(<span class="number">1000</span>),
        log_duration_and_score: <span class="bool-val">true</span>,
        log_final_score_breakdown: <span class="bool-val">true</span>,
        ..Default::default()
    },
};

<span class="comment">// Create and run the solver
</span><span class="kw">let </span>solver = SimulatedAnnealing::new(<span class="kw-2">&amp;</span>config);
<span class="kw">let </span>input = ApiInput { <span class="comment">/* ... */ </span>};
<span class="kw">let </span><span class="kw-2">mut </span>state = State::new(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>;
<span class="kw">let </span>result = solver.solve(<span class="kw-2">&amp;mut </span>state)<span class="question-mark">?</span>;

<span class="macro">println!</span>(<span class="string">"Final score: {}"</span>, result.final_score);
<span class="macro">println!</span>(<span class="string">"Unique contacts: {}"</span>, result.unique_contacts);</code></pre></div>
<h2 id="performance-characteristics"><a class="doc-anchor" href="#performance-characteristics">§</a>Performance Characteristics</h2>
<ul>
<li><strong>Time Complexity</strong>: O(iterations × move_evaluation_cost)</li>
<li><strong>Space Complexity</strong>: O(problem_size) for state storage plus cloning overhead</li>
<li><strong>Convergence</strong>: Typically requires 10,000-100,000 iterations for good solutions</li>
<li><strong>Scaling</strong>: Handles problems with hundreds of people and complex constraints</li>
</ul>
<h2 id="parameter-tuning-guidelines"><a class="doc-anchor" href="#parameter-tuning-guidelines">§</a>Parameter Tuning Guidelines</h2><h3 id="temperature-range"><a class="doc-anchor" href="#temperature-range">§</a>Temperature Range</h3>
<ul>
<li><strong>Initial Temperature</strong>: Set high enough that ~80% of worse moves are initially accepted</li>
<li><strong>Final Temperature</strong>: Set low enough that only small improvements are accepted at the end</li>
<li><strong>Rule of thumb</strong>: <code>initial_temp / final_temp</code> ratio of 100-1000</li>
</ul>
<h3 id="iteration-count"><a class="doc-anchor" href="#iteration-count">§</a>Iteration Count</h3>
<ul>
<li><strong>Small problems</strong> (&lt; 50 people): 10,000-50,000 iterations</li>
<li><strong>Medium problems</strong> (50-200 people): 50,000-200,000 iterations</li>
<li><strong>Large problems</strong> (&gt; 200 people): 200,000+ iterations</li>
</ul>
<h3 id="stop-conditions"><a class="doc-anchor" href="#stop-conditions">§</a>Stop Conditions</h3>
<ul>
<li><strong>Time limits</strong>: Use for production systems with response time requirements</li>
<li><strong>No improvement</strong>: Typically 5-10% of max_iterations for early stopping</li>
<li><strong>Iteration limits</strong>: Primary termination condition for consistent results</li>
</ul>
</div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.max_iterations" class="structfield section-header"><a href="#structfield.max_iterations" class="anchor field">§</a><code>max_iterations: <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.u64.html">u64</a></code></span><div class="docblock"><p>Maximum number of optimization iterations to perform</p>
</div><span id="structfield.initial_temperature" class="structfield section-header"><a href="#structfield.initial_temperature" class="anchor field">§</a><code>initial_temperature: <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.f64.html">f64</a></code></span><div class="docblock"><p>Starting temperature for the annealing schedule</p>
</div><span id="structfield.final_temperature" class="structfield section-header"><a href="#structfield.final_temperature" class="anchor field">§</a><code>final_temperature: <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.f64.html">f64</a></code></span><div class="docblock"><p>Ending temperature for the annealing schedule</p>
</div><span id="structfield.time_limit_seconds" class="structfield section-header"><a href="#structfield.time_limit_seconds" class="anchor field">§</a><code>time_limit_seconds: <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.u64.html">u64</a>&gt;</code></span><div class="docblock"><p>Optional wall-clock time limit in seconds</p>
</div><span id="structfield.no_improvement_iterations" class="structfield section-header"><a href="#structfield.no_improvement_iterations" class="anchor field">§</a><code>no_improvement_iterations: <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.u64.html">u64</a>&gt;</code></span><div class="docblock"><p>Optional early stopping after this many iterations without improvement</p>
</div><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-SimulatedAnnealing" class="impl"><a class="src rightside" href="../../../src/solver_core/algorithms/simulated_annealing.rs.html#158-209">source</a><a href="#impl-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/solver_core/algorithms/simulated_annealing.rs.html#199-208">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(params: &amp;<a class="struct" href="../../models/struct.SolverConfiguration.html" title="struct solver_core::models::SolverConfiguration">SolverConfiguration</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new Simulated Annealing solver from configuration.</p>
<p>Extracts the simulated annealing parameters from the solver configuration
and sets up the algorithm with appropriate stop conditions.</p>
<h5 id="arguments"><a class="doc-anchor" href="#arguments">§</a>Arguments</h5>
<ul>
<li><code>params</code> - Complete solver configuration including SA parameters and stop conditions</li>
</ul>
<h5 id="returns"><a class="doc-anchor" href="#returns">§</a>Returns</h5>
<p>A configured <code>SimulatedAnnealing</code> instance ready to solve problems.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>solver_core::algorithms::simulated_annealing::SimulatedAnnealing;
<span class="kw">use </span>solver_core::models::<span class="kw-2">*</span>;

<span class="kw">let </span>config = SolverConfiguration {
    solver_type: <span class="string">"SimulatedAnnealing"</span>.to_string(),
    stop_conditions: StopConditions {
        max_iterations: <span class="prelude-val">Some</span>(<span class="number">50000</span>),
        time_limit_seconds: <span class="prelude-val">None</span>,
        no_improvement_iterations: <span class="prelude-val">Some</span>(<span class="number">5000</span>),
    },
    solver_params: SolverParams::SimulatedAnnealing(
        SimulatedAnnealingParams {
            initial_temperature: <span class="number">50.0</span>,
            final_temperature: <span class="number">0.1</span>,
            cooling_schedule: <span class="string">"geometric"</span>.to_string(),
        }
    ),
    logging: LoggingOptions::default(),
};

<span class="kw">let </span>solver = SimulatedAnnealing::new(<span class="kw-2">&amp;</span>config);
<span class="macro">assert_eq!</span>(solver.max_iterations, <span class="number">50000</span>);
<span class="macro">assert_eq!</span>(solver.initial_temperature, <span class="number">50.0</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Solver-for-SimulatedAnnealing" class="impl"><a class="src rightside" href="../../../src/solver_core/algorithms/simulated_annealing.rs.html#211-555">source</a><a href="#impl-Solver-for-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../trait.Solver.html" title="trait solver_core::algorithms::Solver">Solver</a> for <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.solve" class="method trait-impl"><a class="src rightside" href="../../../src/solver_core/algorithms/simulated_annealing.rs.html#376-554">source</a><a href="#method.solve" class="anchor">§</a><h4 class="code-header">fn <a href="../trait.Solver.html#tymethod.solve" class="fn">solve</a>(&amp;self, state: &amp;mut <a class="struct" href="../../solver/struct.State.html" title="struct solver_core::solver::State">State</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../../models/struct.SolverResult.html" title="struct solver_core::models::SolverResult">SolverResult</a>, <a class="enum" href="../../solver/enum.SolverError.html" title="enum solver_core::solver::SolverError">SolverError</a>&gt;</h4></section></summary><div class="docblock"><p>Executes the simulated annealing optimization algorithm.</p>
<p>This method implements the complete simulated annealing optimization process,
including temperature scheduling, move generation, acceptance decisions, and
convergence detection. It modifies the provided state to find the best
solution within the configured limits.</p>
<h5 id="algorithm-flow"><a class="doc-anchor" href="#algorithm-flow">§</a>Algorithm Flow</h5>
<ol>
<li><strong>Initialization</strong>: Set up tracking variables and log initial state</li>
<li><strong>Main Loop</strong>: For each iteration:
<ul>
<li>Calculate current temperature using geometric cooling</li>
<li>Choose move type (regular swap vs clique swap) probabilistically</li>
<li>Generate and evaluate a random move</li>
<li>Accept/reject using Metropolis criterion</li>
<li>Update best solution if improved</li>
<li>Check stop conditions</li>
</ul>
</li>
<li><strong>Finalization</strong>: Return best solution found and log results</li>
</ol>
<h5 id="move-selection-strategy"><a class="doc-anchor" href="#move-selection-strategy">§</a>Move Selection Strategy</h5>
<p>The algorithm intelligently chooses between two move types:</p>
<h6 id="clique-swaps-probability-based"><a class="doc-anchor" href="#clique-swaps-probability-based">§</a>Clique Swaps (Probability-Based)</h6>
<ul>
<li>Triggered when <code>calculate_clique_swap_probability()</code> suggests it</li>
<li>Moves entire cliques while respecting constraints</li>
<li>More expensive but handles constraint structure better</li>
<li>Essential for problems with many “must-stay-together” constraints</li>
</ul>
<h6 id="regular-swaps-default"><a class="doc-anchor" href="#regular-swaps-default">§</a>Regular Swaps (Default)</h6>
<ul>
<li>Swaps individual people between groups</li>
<li>Fast to evaluate and execute</li>
<li>Excludes immovable people and clique members</li>
<li>Good for fine-tuning and general optimization</li>
</ul>
<h5 id="acceptance-criterion"><a class="doc-anchor" href="#acceptance-criterion">§</a>Acceptance Criterion</h5>
<p>Uses the Metropolis criterion for probabilistic acceptance:</p>
<div class="example-wrap"><pre class="language-text"><code>if delta_cost &lt; 0:
    accept (improvement)
else:
    accept with probability = exp(-delta_cost / temperature)
</code></pre></div>
<p>This allows exploration of worse solutions early (high temperature) and
focuses on improvements later (low temperature).</p>
<h5 id="arguments-1"><a class="doc-anchor" href="#arguments-1">§</a>Arguments</h5>
<ul>
<li><code>state</code> - Mutable reference to the problem state to optimize</li>
</ul>
<h5 id="returns-1"><a class="doc-anchor" href="#returns-1">§</a>Returns</h5>
<ul>
<li><code>Ok(SolverResult)</code> - The best solution found with detailed scoring</li>
<li><code>Err(SolverError)</code> - If an error occurs during optimization</li>
</ul>
<h5 id="stop-conditions-1"><a class="doc-anchor" href="#stop-conditions-1">§</a>Stop Conditions</h5>
<p>The algorithm stops when the first of these conditions is met:</p>
<ul>
<li><strong>Max iterations</strong>: Reached the configured iteration limit</li>
<li><strong>Time limit</strong>: Exceeded the wall-clock time limit</li>
<li><strong>No improvement</strong>: No better solution found for the specified number of iterations</li>
</ul>
<h5 id="performance-notes"><a class="doc-anchor" href="#performance-notes">§</a>Performance Notes</h5>
<ul>
<li><strong>Memory usage</strong>: Maintains current state + best state (2x problem size)</li>
<li><strong>CPU usage</strong>: Dominated by move evaluation and acceptance calculations</li>
<li><strong>Iteration speed</strong>: Typically 100-10,000 iterations per second depending on problem size</li>
<li><strong>Convergence</strong>: Usually finds good solutions within first 10-20% of iterations</li>
</ul>
<h5 id="logging-output"><a class="doc-anchor" href="#logging-output">§</a>Logging Output</h5>
<p>Controlled by <code>LoggingOptions</code>, the method can output:</p>
<ul>
<li>Initial score breakdown</li>
<li>Periodic progress updates (temperature, contacts, penalties)</li>
<li>Stop condition messages</li>
<li>Final timing and score information</li>
<li>Detailed final score breakdown</li>
</ul>
<h5 id="example-usage-1"><a class="doc-anchor" href="#example-usage-1">§</a>Example Usage</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>solver_core::algorithms::simulated_annealing::SimulatedAnnealing;
<span class="kw">use </span>solver_core::algorithms::Solver;
<span class="kw">use </span>solver_core::models::<span class="kw-2">*</span>;
<span class="kw">use </span>solver_core::solver::State;
<span class="kw">use </span>std::collections::HashMap;

<span class="comment">// Set up the problem and solver
</span><span class="kw">let </span>solver = SimulatedAnnealing::new(<span class="kw-2">&amp;</span>input.solver);
<span class="kw">let </span><span class="kw-2">mut </span>state = State::new(<span class="kw-2">&amp;</span>input)<span class="question-mark">?</span>;

<span class="comment">// Run optimization
</span><span class="kw">let </span>initial_cost = state.calculate_cost();
<span class="kw">let </span>result = solver.solve(<span class="kw-2">&amp;mut </span>state)<span class="question-mark">?</span>;

<span class="comment">// Analyze results
</span><span class="macro">println!</span>(<span class="string">"Optimization completed!"</span>);
<span class="macro">println!</span>(<span class="string">"Initial cost: {:.2}"</span>, initial_cost);
<span class="macro">println!</span>(<span class="string">"Final cost: {:.2}"</span>, result.final_score);
<span class="macro">println!</span>(<span class="string">"Improvement: {:.2}"</span>, initial_cost - result.final_score);
<span class="macro">println!</span>(<span class="string">"Unique contacts achieved: {}"</span>, result.unique_contacts);

<span class="comment">// Access the optimized schedule
</span><span class="kw">for </span>(session, groups) <span class="kw">in </span><span class="kw-2">&amp;</span>result.schedule {
    <span class="macro">println!</span>(<span class="string">"{}:"</span>, session);
    <span class="kw">for </span>(group_name, people) <span class="kw">in </span>groups {
        <span class="macro">println!</span>(<span class="string">"  {}: {:?}"</span>, group_name, people);
    }
}</code></pre></div>
<h5 id="algorithm-details"><a class="doc-anchor" href="#algorithm-details">§</a>Algorithm Details</h5><h6 id="temperature-schedule"><a class="doc-anchor" href="#temperature-schedule">§</a>Temperature Schedule</h6><div class="example-wrap"><pre class="language-text"><code>T(i) = T_initial × (T_final / T_initial)^(i / max_iterations)
</code></pre></div>
<p>This geometric schedule provides smooth cooling from exploration to exploitation.</p>
<h6 id="clique-swap-logic"><a class="doc-anchor" href="#clique-swap-logic">§</a>Clique Swap Logic</h6>
<p>When attempting a clique swap:</p>
<ol>
<li>Select a random clique</li>
<li>Find its current group location</li>
<li>Identify feasible target groups (capacity + constraints)</li>
<li>Select non-clique people to swap out</li>
<li>Evaluate cost delta for the complex move</li>
<li>Apply Metropolis acceptance criterion</li>
</ol>
<h6 id="regular-swap-logic"><a class="doc-anchor" href="#regular-swap-logic">§</a>Regular Swap Logic</h6>
<p>When attempting a regular swap:</p>
<ol>
<li>Filter to swappable people (non-immovable, non-clique)</li>
<li>Select two random people</li>
<li>Evaluate cost delta efficiently</li>
<li>Apply Metropolis acceptance criterion</li>
</ol>
<h5 id="tuning-recommendations"><a class="doc-anchor" href="#tuning-recommendations">§</a>Tuning Recommendations</h5>
<p>For <strong>exploration problems</strong> (many local optima):</p>
<ul>
<li>Increase <code>initial_temperature</code></li>
<li>Increase <code>max_iterations</code></li>
<li>Use longer <code>no_improvement_iterations</code></li>
</ul>
<p>For <strong>exploitation problems</strong> (single broad optimum):</p>
<ul>
<li>Decrease <code>initial_temperature</code></li>
<li>Decrease cooling rate (smaller <code>final_temperature</code>)</li>
<li>Use shorter iteration limits</li>
</ul>
<p>For <strong>constraint-heavy problems</strong>:</p>
<ul>
<li>Increase constraint penalty weights</li>
<li>Monitor clique swap acceptance rates</li>
<li>Use longer optimization times</li>
</ul>
</div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-SimulatedAnnealing" class="impl"><a href="#impl-Freeze-for-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section><section id="impl-RefUnwindSafe-for-SimulatedAnnealing" class="impl"><a href="#impl-RefUnwindSafe-for-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section><section id="impl-Send-for-SimulatedAnnealing" class="impl"><a href="#impl-Send-for-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section><section id="impl-Sync-for-SimulatedAnnealing" class="impl"><a href="#impl-Sync-for-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section><section id="impl-Unpin-for-SimulatedAnnealing" class="impl"><a href="#impl-Unpin-for-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section><section id="impl-UnwindSafe-for-SimulatedAnnealing" class="impl"><a href="#impl-UnwindSafe-for-SimulatedAnnealing" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.SimulatedAnnealing.html" title="struct solver_core::algorithms::simulated_annealing::SimulatedAnnealing">SimulatedAnnealing</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.79.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.79.0/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.79.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.79.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.79.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.79.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.79.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.79.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.79.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.79.0/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.79.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.79.0/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.79.0/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.79.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.79.0/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.79.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.79.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details></div></section></div></main></body></html>