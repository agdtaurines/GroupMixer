searchState.loadedDescShard("solver_core", 0, "Solver-Core: Advanced Group Distribution Optimization …\nOptimization algorithms for the solver-core.\nData models and types for the solver-core API.\nRuns the optimization solver with the given input …\nCore solver state management and optimization logic.\nA trait that all solver algorithms must implement.\nSimulated Annealing optimization algorithm implementation.\nRuns the optimization algorithm on the given state.\nSimulated Annealing solver for the Social Group Scheduling …\nEnding temperature for the annealing schedule\nReturns the argument unchanged.\nStarting temperature for the annealing schedule\nCalls <code>U::from(self)</code>.\nMaximum number of optimization iterations to perform\nCreates a new Simulated Annealing solver from …\nOptional early stopping after this many iterations without …\nExecutes the simulated annealing optimization algorithm.\nOptional wall-clock time limit in seconds\nComplete input specification for the optimization solver.\nMaintains desired attribute distributions within specific …\nParameters for the AttributeBalance constraint.\nPrevents specified people from being in the same group\nRepresents a constraint that must be satisfied or …\nRepresents a group that people can be assigned to.\nFixes specific people to specific groups in specific …\nParameters for the ImmovablePerson constraint.\nConfiguration options for logging and output during …\nKeeps specified people in the same group\nDefines an optimization objective with its weight.\nRepresents a person who can be scheduled into groups.\nDefines the core optimization problem: people, groups, and …\nLimits how often people can encounter each other across …\nParameters for the RepeatEncounter constraint.\nParameters for the Simulated Annealing algorithm\nParameters specific to the Simulated Annealing algorithm.\nComplete configuration for the optimization solver.\nAlgorithm-specific parameters for different solver types.\nThe result returned by the optimization solver.\nDefines when the optimization process should stop.\nPenalty points for attribute balance violations\nThe attribute key to balance (e.g., “gender”, “…\nKey-value attributes used for constraint evaluation (e.g., …\nTotal penalty points for constraint violations\nConstraints that must be satisfied or penalized (defaults …\nTemperature reduction schedule: “geometric” for …\nDesired count for each attribute value (e.g., {“male”: …\nFormats the schedule as a human-readable string.\nWhether to display the final schedule in a human-readable …\nOverall optimization score (higher is better)\nEnding temperature (lower values focus on local …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nID of the group where this balance constraint applies\nID of the group where this person must be placed\nList of all available groups with their capacity limits\nUnique identifier for this person (must be unique across …\nUnique identifier for this group (must be unique across …\nStarting temperature (higher values allow more random …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether to log the total optimization time and final score\nWhether to log a detailed breakdown of the final score\nHow often to log progress (every N iterations). <code>None</code> …\nWhether to log a detailed breakdown of the initial score\nWhether to log the initial state and configuration\nWhether to log the reason why optimization stopped\nLogging and output preferences (defaults to minimal …\nMaximum number of times two people can be in the same group\nMaximum number of optimization iterations before stopping\nStop if no improvement found for this many iterations\nTotal number of scheduling sessions (time periods)\nOptimization objectives (defaults to empty list if not …\nPenalty function type: “squared” for quadratic …\nWeight of the penalty applied for constraint violations\nWeight of the penalty applied for balance violations\nList of all people to be scheduled into groups\nID of the person who must be fixed in place\nThe core problem definition: people, groups, and sessions\nPenalty points for exceeding repeat encounter limits\nThe optimized schedule: <code>schedule[session][group] = [people]</code>\nOptional list of session indices this person participates …\nList of session indices where this person must be in the …\nMaximum number of people that can be assigned to this …\nSolver algorithm configuration and parameters\nAlgorithm-specific parameters\nType of solver algorithm to use (currently “…\nConditions that determine when to stop optimization\nMaximum time in seconds before stopping\nThe type of objective to optimize for\nNumber of unique person-to-person contacts achieved\nWeight of this objective in the overall optimization …\nPenalty weight for violations (higher = more important)\nPenalty weight for violations (higher = more important)\nList of person IDs that must stay together\nList of person IDs that cannot be together\nOptional list of session indices where this constraint …\nOptional list of session indices where this constraint …\nErrors that can occur during solver operation.\nThe internal state of the solver, optimized for …\nA constraint validation error with descriptive message.\nApply a clique swap, moving the clique to a new group and …\nExecutes a swap of two people between groups and updates …\nFor each attribute, maps integer indices back to value …\nMaps attribute keys (e.g., “gender”) to integer indices\nFor each attribute, maps values (e.g., “male”) to …\nAttribute balance constraints (copied from input for …\nCurrent penalty for attribute balance violations\nCalculate the cost delta for swapping a clique with …\nCalculate the probability of attempting a clique swap …\nCalculates the change in the total cost function if a swap …\nWhich sessions each clique constraint applies to (None = …\nNumber of violations for each clique (people not staying …\nPenalty weight for each clique violation\nMerged cliques (groups of people who must stay together)\nTotal constraint penalty (sum of individual constraint …\nContact matrix: …\nFind all non-clique, movable people in a specific group …\nWhich sessions each forbidden pair constraint applies to …\nNumber of violations for each forbidden pair (people …\nPenalty weight for each forbidden pair violation\nPairs of people who cannot be together\nFormats a detailed breakdown of the current solution’s …\nReturns the argument unchanged.\nReturns the argument unchanged.\nMaps group ID strings to integer indices for fast array …\nMaps integer indices back to group ID strings for result …\nImmovable person assignments: …\nTotal violations of immovable person constraints\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a clique swap is feasible between two groups\nFast person location lookup: …\nLogging and output configuration options\nCreates a new solver state from the API input …\nTotal number of sessions in the problem\nPerson attributes in integer form: …\nMaps person ID strings to integer indices for fast array …\nMaps integer indices back to person ID strings for result …\nPerson participation matrix: …\nMaps each person to their clique index (None if not in a …\nCurrent penalty for exceeding repeat encounter limits\nThe main schedule: …\nConverts the current state to an API result format.\nCurrent number of unique person-to-person contacts\nWeight for maximizing unique contacts (from objectives)\nWeight for repeat encounter penalties (from constraints)")